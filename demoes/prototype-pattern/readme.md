## 【创建型】原型模式

### A1 
创建新对象时是基于一个对象的拷贝，而不是重新实例化一个类。

举例说明，比如上例中的 peopleConfig，其实 peopleConfig 应该是有固定模板的：
```ts
// 这样每次返回的都是新的对象，也可以相当于是对象的拷贝
function peopleConfigPrototype() {
  return {
    name: '',
    age: 0,
    des: ''
  }
}

// 直接拷贝对象
const peopleConfigPrototype = {
  name: '',
  age: 0,
  des: ''
}
const peopleConfig = Object.create(peopleConfigPrototype)
```

### A2
原型模式是在同一类型的许多对象之间共享属性的有用方法。该原型是JavaScript的原生对象，可以通过原型链通过对象访问。

在我们的应用程序中，我们经常需要创建许多相同类型的对象。一个有用的方法是创建一个 ES6 类的多个实例。

假设我们要创建许多狗！在我们的例子中，狗不能做那么多：它们只是有一个名字，它们可以吠叫！

请注意这里的构造函数如何包含一个 name 属性，而类本身包含一个 bark 属性。当使用 ES6 类时，在类本身上定义的所有属性，在本例中为 bark，都会自动添加到原型中。

我们可以通过访问构造函数的原型属性，或通过任何实例的 `__proto__` 属性直接看到原型。

任何构造函数实例上的 `__proto__` 值，都是对构造函数原型的直接引用！每当我们尝试直接访问对象上不存在的属性时，JavaScript 将沿着原型链查看该属性是否在原型链中可用。

在处理应该可以访问相同属性的对象时，原型模式非常强大。我们可以简单地将属性添加到原型中，而不是每次都创建属性的副本，因为所有实例都可以访问原型对象。

由于所有实例都可以访问原型，因此即使在创建实例之后也很容易向原型添加属性。

说我们的狗不仅应该会叫，还应该会玩！我们可以通过在原型中添加一个 play 属性来实现这一点。
```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    return `Woof!`;
  }
}
const dog1 = new Dog("Daisy");
console.log(Dog.prototype);
// constructor: ƒ Dog(name, breed) bark: ƒ bark()

console.log(dog1.__proto__);
// constructor: ƒ Dog(name, breed) bark: ƒ bark()
Dog.prototype.play = () => console.log("Playing now!");

dog1.play();
```

原型链一词表明可能有不止一个步骤。的确！到目前为止，我们只看到了如何访问 `__proto__` 引用的第一个对象上直接可用的属性。然而，原型本身也有一个 `__proto__` 对象！
让我们创造另一种狗，超级狗！这只狗应该继承普通狗的一切，但它也应该能够飞。我们可以通过扩展 Dog 类并添加 fly 方法来创建超级狗。'

```js
class SuperDog extends Dog {
  constructor(name) {
    super(name);
  }

  fly() {
    return "Flying!";
  }
}
```

我们可以访问 bark 方法，因为我们扩展了 Dog 类。 SuperDog原型上的 `__proto__` 值指向Dog.prototype对象！

很清楚为什么它被称为原型链：当我们尝试访问对象上不直接可用的属性时，JavaScript 会递归地遍历 `__proto__` 指向的所有对象，直到找到该属性！

Object.create 方法允许我们创建一个新对象，我们可以将其原型的值显式传递给该对象。
```js
const dog = {
  bark() {
    console.log(`Woof!`);
  }
};

const pet1 = Object.create(dog);

pet1.bark(); // Woof!
console.log("Direct properties on pet1: ", Object.keys(pet1));
console.log("Properties on pet1's prototype: ", Object.keys(pet1.__proto__));
```
虽然 pet1 本身没有任何属性，但它确实可以访问其原型链上的属性！由于我们将 dog 对象作为 pet1 的原型传递，我们可以访问 bark 属性。

Object.create 是一种让对象直接从其他对象继承属性的简单方法，通过指定新创建对象的原型。新对象可以通过原型链访问新属性。

原型模式允许我们轻松地让对象访问和继承其他对象的属性。由于原型链允许我们访问不是直接在对象本身上定义的属性，我们可以避免方法和属性的重复，从而减少使用的内存量。

### A3
意图
原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。

问题
如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。

不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。

直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。

解决方案
原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。

所有的类对 克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。

其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。

真实世界类比
现实生活中， 产品在得到大规模生产前会使用原型进行各种测试。 但在这种情况下， 原型只是一种被动的工具， 不参与任何真正的生产活动。

由于工业原型并不是真正意义上的自我复制， 因此细胞有丝分裂 （还记得生物学知识吗？） 或许是更恰当的类比。 有丝分裂会产生一对完全相同的细胞。 原始细胞就是一个原型， 它在复制体的生成过程中起到了推动作用。

原型模式适合应用场景
如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。

这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。

原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。

如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。

在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。

客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。

实现方式
创建原型接口， 并在其中声明 克隆方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。

原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。

如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。

克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 否则， 克隆方法可能会生成父类的对象。

你还可以创建一个中心化原型注册表， 用于存储常用原型。

你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。

最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。

优点
你可以克隆对象， 而无需与它们所属的具体类相耦合。
你可以克隆预生成原型， 避免反复运行初始化代码。
你可以更方便地生成复杂对象。
你可以用继承以外的方式来处理复杂对象的不同配置。

缺点
克隆包含循环引用的复杂对象可能会非常麻烦。